import Gaussian.Gaussian
import Mathlib.Probability.Density
import Mathlib.Probability.Notation
import Mathlib.Analysis.SpecialFunctions.ExpDeriv
import Mathlib.Topology.Basic
import Mathlib.Probability.Cdf

import Mathlib.MeasureTheory.Constructions.Pi
import Mathlib.MeasureTheory.Measure.Stieltjes
import Mathlib.MeasureTheory.Measure.Haar.OfBasis

open scoped ENNReal NNReal Real

/--- Define the PDF of exponential Probability depending on its Rate-/
noncomputable
def exponentialPDFReal (rate : ℝ) (ratePos : 0 < rate) (x : ℝ): ℝ :=
ite (x ≥ 0) (rate*(Real.exp (-(↑rate*↑x)))) 0

/- The PDF on the extended real Numbers-/
noncomputable
def exponentialPDF (rate : ℝ) (ratePos : rate > 0) (x : ℝ) : ℝ≥0∞ :=
  ENNReal.ofReal (exponentialPDFReal rate ratePos x)

open MeasureTheory
open Measure


lemma root_of_exp_pos {rate : ℝ} (ratePos : 0 < rate) :
  ∀ x ∈ (Set.Ici 0), HasDerivAt (fun a => -1/(↑rate) * (Real.exp (-(↑rate * a)))) (Real.exp (-(↑rate * x))) x := by
  intro x _; convert (((hasDerivAt_pow 1 x).const_mul (-↑rate)).exp.const_mul (-1/(↑ rate))) using 1;
  . simp only [pow_one, neg_mul];
  simp only [pow_one, neg_mul, Nat.cast_one, le_refl, tsub_eq_zero_of_le, pow_zero, mul_one, mul_neg];
  rw[mul_comm (rexp _),<-neg_mul (-1/rate),<- neg_div, <-mul_assoc]; simp only [neg_neg,
    one_div, ne_eq]; rw[inv_mul_cancel ?_]; ring; exact ne_of_gt ratePos


lemma lt_ge_disjoint (c : ℝ) : Disjoint {x : ℝ | x ≥ c} {x | x < c} := by
  rw [@Set.disjoint_iff]; rintro x ⟨hxge, hxlt⟩; dsimp at *; linarith

lemma real_open_is_measurable {s : Set ℝ} (h: IsOpen s) : MeasurableSet s := by apply IsOpen.measurableSet h

lemma comp_of_ge : {x : ℝ | x ≥ 0}ᶜ =  {x | x < 0} := by ext x; constructor <;> simp


lemma comp_of_le : {x :ℝ  | x ≤  0}ᶜ =  {x | x > 0} := by
  ext x; constructor;
  simp only [ Set.setOf_eq_eq_singleton, Set.mem_compl_iff, Set.mem_singleton_iff, gt_iff_lt, Set.mem_setOf_eq];
  push_neg; intro hx; exact hx; simp only [gt_iff_lt,
  Set.mem_setOf_eq, Set.mem_compl_iff, not_le, imp_self]


/- Splitting the integral for the own version of the case -/

lemma lintegral_eq_lt_and_ge (f: ℝ → ENNReal) (c : ℝ) :  ∫⁻ (x : ℝ), f x  =  (∫⁻ (x : ℝ) in {x | x ≥ c}, f x) +  ∫⁻ (x : ℝ) in {x | x < c}, f x := by
  have union : Set.univ = {x: ℝ | x ≥ c} ∪ {x : ℝ | x < c} := by
    ext x; constructor; intro _; by_cases x ≥ c; left; exact h
    push_neg at h; right; exact h
    intro hx; rcases hx  <;> trivial
  have : IsOpen {x : ℝ | x < c} := by exact isOpen_gt' c
  calc
  ∫⁻ (x : ℝ), f x = ∫⁻ (x : ℝ) in Set.univ, f x ∂ volume := by exact (set_lintegral_univ fun x => f x).symm
  _ = ∫⁻ (x : ℝ) in {x | x ≥ c} ∪ {x | x < c} , f x ∂ volume := by rw [<-union]
  _ = _ := by
    apply lintegral_union;
    . refine real_open_is_measurable this
    . rw [@Set.disjoint_iff]; rintro x ⟨hxge, hxlt⟩; dsimp only [Set.mem_setOf_eq] at *; linarith --with lemma lt_ge_disjoint?

lemma lintegral_eq_lt_and_ge_bounded {y : ℝ}(f: ℝ → ENNReal) (c : ℝ) (yNonneg: 0 ≤ y) :  ∫⁻ (x : ℝ) in Set.Iic y, f x  =  (∫⁻ (x : ℝ) in Set.Iic 0, f x) +  ∫⁻ (x : ℝ) in Set.Ioc 0 y, f x := by
  have union : Set.Iic y = Set.Iic 0 ∪ Set.Ioc 0 y := by
    ext x; constructor
    . simp only [Set.mem_Iic, gt_iff_lt, not_lt, ge_iff_le, Set.mem_union, Set.mem_Ioc];
      intro hxy; by_cases x ≤ 0; left; exact h; right; constructor <;> linarith
    simp only [gt_iff_lt, not_lt, ge_iff_le, Set.mem_union, Set.mem_Iic, Set.mem_Ioc]; intro hxy
    rcases hxy with h | h;
    . exact le_trans h yNonneg
    . linarith
  rw[union]; apply lintegral_union; exact measurableSet_Ioc;
  rw [Set.disjoint_iff]; rintro x ⟨h1, h2⟩;
  simp only [Set.mem_Iic] at h1 ; simp only [gt_iff_lt, not_lt, ge_iff_le, Set.mem_Ioc] at h2
  linarith

lemma lintegral_nonpos_eq_zero {x rate : ℝ} (ratePos: 0 < rate) (xNonpos: x ≤ 0) : ∫⁻ (y : ℝ) in Set.Iio x, (exponentialPDF rate ratePos y) = ENNReal.ofReal 0 := by
  unfold exponentialPDF exponentialPDFReal;
  rw [set_lintegral_congr_fun (g:=(fun _ => 0))]; rw [@lintegral_zero]; exact ENNReal.ofReal_zero.symm
  exact measurableSet_Iio
  refine ae_of_all _ ?_; intro a ha; simp only [Set.mem_Iio] at ha; simp only [ge_iff_le, ENNReal.ofReal_eq_zero]
  rw [if_neg]; linarith

open ProbabilityTheory

/-- The exponential pdf is measurable. -/

lemma measurable_exponentialPDFReal (rate : ℝ) (ratePos : rate > 0) : Measurable (exponentialPDFReal rate ratePos) := by
  have : Measurable fun x => (rate*(Real.exp (-(↑rate*↑x)))):= (measurable_id'.const_mul rate).neg.exp.const_mul rate
  unfold exponentialPDFReal; refine Measurable.ite ?hp this ?hg;
  . refine MeasurableSet.of_compl ?hp.h; apply real_open_is_measurable; rw [comp_of_ge]; exact isOpen_gt' 0 ;
  . exact measurable_const


/-- The exponential pdf is strongly measurable. Needed to transfer lintegral to integral -/

lemma stronglyMeasurable_exponentialPDFReal (rate : ℝ) (ratePos : rate > 0) :
    StronglyMeasurable (exponentialPDFReal rate ratePos) :=
  (measurable_exponentialPDFReal rate ratePos).stronglyMeasurable

lemma exponentialPDFReal_pos (xPos : 0 < x) : exponentialPDFReal rate ratePos x > 0 := by
  unfold exponentialPDFReal
  conv =>
    lhs
    rw[if_pos (le_of_lt xPos)]
  exact mul_pos ratePos (Real.exp_pos _)

lemma exponentialPDFReal_nonneg :∀ x : ℝ, exponentialPDFReal rate ratePos x ≥ 0 := by
  unfold exponentialPDFReal
  intro x;
  by_cases x ≥  0
  . conv =>
      lhs
      rw[if_pos h]
    exact mul_nonneg (le_of_lt ratePos) (le_of_lt (Real.exp_pos _))
  . conv  =>
      lhs
      rw[if_neg h]

lemma IntSeqMonotone : Monotone (fun n : ℕ  => Set.Icc (0 : ℝ) ↑n) := by
  refine monotone_nat_of_le_succ ?hf; intro n; refine Set.le_iff_subset.mpr ?hf.a; refine
    Set.Icc_subset_Icc_right ?hf.a.h; refine Nat.cast_le.mpr ?hf.a.h.a; simp only [le_add_iff_nonneg_right]

lemma UnionofIcc : (⋃ n : ℕ , Set.Icc (0 : ℝ) ↑n) = Set.Ici 0 := by
  ext x;
  simp only [ge_iff_le, Nat.cast_nonneg, not_true, gt_iff_lt, Set.mem_iUnion, Set.mem_Icc,
    exists_and_left, Set.mem_Ici, and_imp, forall_exists_index];
  constructor; intro h; exact h.1
  intro h; constructor; exact h; exact exists_nat_ge x

lemma IntegrableOnposInterval {b : ℝ} (hb : 0 < b) :
  IntegrableOn (fun x => rexp (-(b * x))) (⋃ (n : ℕ), Set.Icc (0 : ℝ) ↑n) := by
  rw [UnionofIcc]
  have : ∀ x : ℝ , (rexp (-(b * x)) = rexp (-b * x)) := by intro x; rw [@neg_mul_eq_neg_mul]
  simp only [this]
  apply integrableOn_Ici_iff_integrableOn_Ioi.2 (exp_neg_integrableOn_Ioi 0 hb)


/- Own approach, stays in lintegral for longer, right now end at Part of trying to integrate right side (the real domain of definition) to 1, because of lintegral-/

lemma if_eval_pos : ∀ᵐ  x : ℝ ∂ volume , (x ∈ {x|x < 0} →
   ENNReal.ofReal (if ((x : ℝ) ≥  0) then ( (rate * rexp (-(↑rate * x)))) else 0 ) = 0 ):= by
      apply ae_of_all
      intro x hx; split_ifs with h; simp only [ge_iff_le] at h ;
      . contrapose h; push_neg; exact hx
      . exact ENNReal.ofReal_zero

lemma if_eval_neg :  ∀ᵐ  x : ℝ ∂ volume , (x ∈ {x|x ≥ 0} →
  ENNReal.ofReal (if ((x : ℝ) ≥  0) then (rate * rexp (-(↑rate * x))) else 0 ) = ENNReal.ofReal (rate * rexp (-(↑rate * x))) ):= by
    apply ae_of_all
    intro x hx; split_ifs with h; simp only [ge_iff_le] at h ;
    . rfl
    contrapose h; simp only [ge_iff_le, not_le, not_lt]; exact hx

lemma rootTendsZero {rate : ℝ} : rate > 0 →  Filter.Tendsto (fun x => -1/(rate) * (Real.exp (-(rate * x)))) Filter.atTop (nhds 0) := by
  rw [@Metric.tendsto_atTop]; intro ratePos ε εpos;
  by_cases ε * rate < 1
  use (2*(-(rate)⁻¹*(Real.log (ε * rate)))); intro n hn
  simp only [dist_zero_right, norm_mul, norm_div, norm_neg, norm_one, Real.norm_eq_abs, abs_eq,
  Real.abs_exp, one_div, ne_eq, NNReal.coe_eq_zero]; apply lt_of_mul_lt_mul_left _ (le_of_lt ratePos); rw[<-mul_assoc, abs_eq_self.2 (le_of_lt ratePos) , mul_inv_cancel, one_mul, <-Real.lt_log_iff_exp_lt (mul_pos ratePos εpos), neg_lt];
  have invPos: (0 : ℝ) < (↑rate)⁻¹  := by apply inv_pos.2 ratePos
  apply lt_of_mul_lt_mul_left (b:=-Real.log (↑rate * ε)) _ (le_of_lt invPos);
  simp only [NNReal.val_eq_coe, NNReal.coe_inv, mul_neg, NNReal.coe_eq_zero]
  rw[<-mul_assoc, inv_mul_cancel, one_mul]
  apply lt_of_le_of_lt' hn; rw[mul_comm ε, neg_mul]; nth_rw 1 [<-one_mul (-((↑rate)⁻¹ * Real.log (↑rate * ε)))]
  apply mul_lt_mul_of_pos_right; norm_num; simp; apply mul_neg_of_pos_of_neg; apply invPos; apply Real.log_neg
  exact mul_pos ratePos εpos; rw [mul_comm]; exact h; intro fal; linarith; linarith;
  push_neg at h
  use 1; intro n hn; simp only [dist_zero_right, norm_mul, norm_div, norm_neg, norm_one, Real.norm_eq_abs, one_div,
  Real.abs_exp, abs_eq_self.2 (le_of_lt ratePos)];
  apply lt_of_mul_lt_mul_left _ (le_of_lt ratePos); rw[<-mul_assoc, mul_inv_cancel, one_mul, mul_comm rate ε];
  apply lt_of_le_of_lt' h; refine Real.exp_lt_one_iff.mpr ?_; refine neg_lt_zero.mpr ?_;
  exact lt_mul_of_lt_of_one_le_of_nonneg ratePos hn (le_of_lt ratePos)
  linarith

  lemma rootTendsZero2 {rate : ℝ} : rate > 0 →  Filter.Tendsto (fun x => -1/(rate) * (Real.exp (-(rate * x)))) Filter.atTop (nhds 0) := by
    --intro ratePos; rw[<-mul_zero (-1/rate)]; apply ENNReal.Tendsto.const_mul (a:=(-1/rate)) (b:=0) (f:=Filter.atTop) (m:=(fun x => (Real.exp (-(rate * x)))))
    sorry

lemma lintegral_exponentialPDFReal_eq_one (rate : ℝ) (ratePos : (0 : ℝ) < rate) :
  ∫⁻ (x : ℝ), exponentialPDF rate ratePos x = 1 := by
    rw [lintegral_eq_lt_and_ge (exponentialPDF rate ratePos) 0, ←ENNReal.toReal_eq_one_iff];

    have leftSide: ∫⁻ (x : ℝ) in {x | x < 0}, exponentialPDF rate ratePos x = 0 := by
      unfold exponentialPDF exponentialPDFReal; rw [set_lintegral_congr_fun (real_open_is_measurable (isOpen_gt' 0)) if_eval_pos]; exact lintegral_zero
    have rightSide: ∫⁻ (x : ℝ) in {x | x ≥ 0}, exponentialPDF rate ratePos x = ∫⁻ (x : ℝ) in {x | x ≥ 0}, ENNReal.ofReal (rate * rexp (-(rate * x))) := by
      unfold exponentialPDF exponentialPDFReal; apply set_lintegral_congr_fun _ _
      . refine MeasurableSet.of_compl ?h; rw [comp_of_ge]; refine real_open_is_measurable ?h.h; exact isOpen_gt' 0;
      exact if_eval_neg

    rw [leftSide]; simp only [ge_iff_le, add_zero];
    rw [rightSide, ENNReal.toReal_eq_one_iff, ←ENNReal.toReal_eq_one_iff]

    have hf : 0 ≤ᵐ[(restrictₗ {x:ℝ | x ≥ 0}) ℙ] (fun x => rate * (rexp (-(rate * x)))) := by
      apply ae_of_all _ ?a;
      simp only [Pi.zero_apply, gt_iff_lt, NNReal.coe_pos]; intro a; apply le_of_lt; rw[<-zero_mul 0]; apply mul_lt_mul'' ratePos (Real.exp_pos (-(rate * a))); trivial; trivial

    rw [← @restrictₗ_apply, ← integral_eq_lintegral_of_nonneg_ae hf ?_]
    . simp only [ge_iff_le, restrictₗ_apply]; rw [@integral_mul_left, Set.Ici_def];
      rw [@integral_Ici_eq_integral_Ioi]
      have IntegrOn : IntegrableOn (fun x => rexp (-(rate * x))) (Set.Ioi 0) := by simp only [<-neg_mul]; apply exp_neg_integrableOn_Ioi 0 ratePos
      rw [integral_Ioi_of_hasDerivAt_of_tendsto' (root_of_exp_pos ratePos) IntegrOn (rootTendsZero ratePos)]
      simp only [mul_zero, neg_zero, Real.exp_zero, mul_one, _root_.zero_sub]; rw [neg_div]; simp only [one_div,neg_neg, ne_eq, NNReal.coe_eq_zero]; rw[mul_inv_cancel]; linarith
    apply ((measurable_id'.const_mul rate).neg.exp.const_mul rate).stronglyMeasurable.aestronglyMeasurable

@[simp]
lemma lintegral_exponentialPDF_eq_one (rate : ℝ) (ratePos : (0 : ℝ) < rate) :
    ∫⁻ x, exponentialPDF rate ratePos x = 1 :=
  lintegral_exponentialPDFReal_eq_one rate ratePos

open MeasureTheory

/- Measure defined by the exponential Distribution -/

noncomputable
def expMeasure (rate : ℝ) (ratePos : rate > 0) : Measure ℝ :=
   volume.withDensity (exponentialPDF rate ratePos)

instance instIsProbabilityMeasureExponential (rate : ℝ) (ratePos: 0 < rate) :
    IsProbabilityMeasure (expMeasure rate ratePos) where
  measure_univ := by unfold expMeasure; simp only [MeasurableSet.univ, withDensity_apply, restrict_univ,
    lintegral_exponentialPDF_eq_one]

/-- CDF -/
noncomputable
def exponentialCDFReal (rate : ℝ) (ratePos : 0 < rate) : StieltjesFunction :=
      ProbabilityTheory.cdf (expMeasure rate ratePos)

--lemma root_of_exp {rate : ℝ} (ratePos: 0 < rate) : ∀ x : ℝ, HasDerivAt (exponentialCDFReal rate ratePos).toFun (exponentialPDFReal rate ratePos x) x := by


lemma ExpCDF_eq_integral (rate : ℝ) (ratePos: 0 < rate) : ((exponentialCDFReal rate ratePos) x) = ∫ x in (Set.Iic x), exponentialPDFReal rate ratePos x := by
  unfold exponentialCDFReal; rw [ProbabilityTheory.cdf_eq_toReal];
  unfold expMeasure; simp only [measurableSet_Iic, withDensity_apply];
  rw [integral_eq_lintegral_of_nonneg_ae]; exact rfl;
  . apply ae_of_all _ ?a; simp only [Pi.zero_apply]; intro a; exact exponentialPDFReal_nonneg a
  refine AEStronglyMeasurable.restrict ?hfm.hfm;
  refine Measurable.aestronglyMeasurable ?hfm.hfm.hf;
  exact measurable_exponentialPDFReal rate ratePos

lemma ExpCDF_eq_lintegral (rate : ℝ) (ratePos: 0 < rate) : ((exponentialCDFReal rate ratePos) x) =ENNReal.toReal (∫⁻ x in (Set.Iic x), ENNReal.ofReal (exponentialPDFReal rate ratePos x)) := by
  unfold exponentialCDFReal; rw [ProbabilityTheory.cdf_eq_toReal];
  unfold expMeasure; simp only [measurableSet_Iic, withDensity_apply];
  exact rfl

lemma int_eq_root (rate : ℝ) (ratePos: 0 < rate) : ∀ x:ℝ, (∫⁻ y in (Set.Iic x), ENNReal.ofReal (exponentialPDFReal rate ratePos y) = ENNReal.ofReal ( ite (x ≥ 0) (-1/(rate) * (Real.exp (-(rate * x)))) 0)) := by
  intro x; split_ifs with h
  case neg; unfold exponentialPDFReal;
  rw [set_lintegral_congr_fun (g:=(fun x => 0))]; rw [@lintegral_zero]; exact ENNReal.ofReal_zero.symm
  exact measurableSet_Iic
  refine ae_of_all ℙ ?_; intro a ha; simp only [Set.mem_Iic] at ha; simp only [ge_iff_le, ENNReal.ofReal_eq_zero]
  rw [if_neg]; linarith
  rw [lintegral_eq_lt_and_ge_bounded]; 



lemma Deriv_of_CDF_eq_PDF_ae (rate) (ratePos : 0 < rate) : ∀ᶠ x in univ, HasDerivAt (exponentialCDFReal rate ratePos).toFun (exponentialPDFReal rate ratePos x) x:= by
  unfold exponentialCDFReal; --rw [ProbabilityTheory.ofReal_cdf]
  refine Filter.eventually_of_forall ?hp; intro x;

lemma CDF_eq_root : (exponentialCDFReal rate ratePos).toFun = fun x => ite (x ≥ 0) (-1/(rate) * (Real.exp (-(rate * x)))) 0 := by
  ext x; rw [ExpCDF_eq_int]
