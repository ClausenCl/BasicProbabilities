import Gaussian.Gaussian
import Mathlib.Probability.Density
import Mathlib.Probability.Notation
import Mathlib.Analysis.SpecialFunctions.ExpDeriv
import Mathlib.Topology.Basic

open scoped ENNReal NNReal Real

/--- Define the PDF of exponential Probability depending on its Rate-/

noncomputable
def exponentialPDFReal (rate : ‚Ñù) (ratePos : rate > 0) (x : ‚Ñù): ‚Ñù :=
ite (x ‚â• 0) (rate*(Real.exp (-(‚Üërate*‚Üëx)))) 0

/- The PDF on the extended real Numbers-/
noncomputable
def exponentialPDF (rate : ‚Ñù) (ratePos : rate > 0) (x : ‚Ñù) : ‚Ñù‚â•0‚àû :=
  ENNReal.ofReal (exponentialPDFReal rate ratePos x)

open MeasureTheory
open Measure


lemma root_of_exp {rate : ‚Ñù} (ratePos : 0 < rate) :  ‚àÄ x ‚àà (Set.Ici 0), HasDerivAt (fun a => -1/(‚Üërate) * (Real.exp (-(‚Üërate * a)))) (Real.exp (-(‚Üërate * x))) x := by
  intro x hx; convert (((hasDerivAt_pow 1 x).const_mul (-‚Üërate)).exp.const_mul (-1/(‚Üë rate))) using 1;
  . simp only [pow_one, neg_mul];
  simp only [pow_one, neg_mul, Nat.cast_one, le_refl, tsub_eq_zero_of_le, pow_zero, mul_one, mul_neg]; rw[mul_comm (rexp _),<-neg_mul (-1/rate),<- neg_div, <-mul_assoc]; simp only [neg_neg,
    one_div, ne_eq]; rw[inv_mul_cancel ?_]; ring; exact ne_of_gt ratePos

lemma lt_ge_disjoint (x c : ‚Ñù) : Disjoint {x : ‚Ñù | x ‚â• c} {x | x < c} := by
  rw [@Set.disjoint_iff]; rintro x ‚ü®hxge, hxlt‚ü©; dsimp at *; linarith

lemma real_open_is_measurable {s : Set ‚Ñù} (h: IsOpen s) : MeasurableSet s := by apply IsOpen.measurableSet h

lemma comp_of_ge {x : ‚Ñù} : {x : ‚Ñù | x ‚â• 0}·∂ú =  {x | x < 0} := by ext x; constructor <;> simp


lemma comp_of_le {x : ‚Ñù} : {x :‚Ñù  | x ‚â§  0}·∂ú =  {x | x > 0} := by ext x; constructor; simp only [ Set.setOf_eq_eq_singleton, Set.mem_compl_iff, Set.mem_singleton_iff, gt_iff_lt, Set.mem_setOf_eq]; push_neg; intro hx; exact hx; simp only [gt_iff_lt,
  Set.mem_setOf_eq, Set.mem_compl_iff, not_le, imp_self]

/- Split integral for real case (R√©mys approach), need the integratable statements so that integral union is usable -/

lemma integral_eq_lt_and_ge (f: ‚Ñù ‚Üí ‚Ñù) (c : ‚Ñù)  : (IntGE : IntegrableOn (fun x => f x) {x | x ‚â• c}) ‚Üí
      (IntLT : IntegrableOn (fun x => f x) {x | x < c}) ‚Üí ‚à´ (x : ‚Ñù), f x  =  (‚à´ (x : ‚Ñù) in {x | x ‚â• c}, f x) +  ‚à´ (x : ‚Ñù) in {x | x < c}, f x := by

  have union : Set.univ = {x: ‚Ñù | x ‚â• c} ‚à™ {x : ‚Ñù | x < c} := by
    ext x; constructor; intro hx; by_cases x ‚â• c; left; exact h
    push_neg at h; right; exact h
    intro hx; rcases hx  <;> trivial
  have : IsOpen {x : ‚Ñù | x < c} := by exact isOpen_gt' c
  intro IntGE IntLT
  calc
  ‚à´ (x : ‚Ñù), f x = ‚à´ (x : ‚Ñù) in Set.univ, f x := by rw [integral_univ]
  _ = ‚à´ (x : ‚Ñù) in {x | x ‚â• c} ‚à™ {x | x < c} , f x ‚àÇ volume := by rw [<-union]
  _ = _ := by
    apply integral_union;
    . apply (lt_ge_disjoint _ c); exact c;
    . exact real_open_is_measurable this
    . exact IntGE
    . exact IntLT


/- Splitting the integral for the own version o the case -/

lemma lintegral_eq_lt_and_ge1 (f: ‚Ñù ‚Üí ENNReal) (c : ‚Ñù) :  ‚à´‚Åª (x : ‚Ñù), f x  =  (‚à´‚Åª (x : ‚Ñù) in {x | x ‚â• c}, f x) +  ‚à´‚Åª (x : ‚Ñù) in {x | x < c}, f x := by
  have union : Set.univ = {x: ‚Ñù | x ‚â• c} ‚à™ {x : ‚Ñù | x < c} := by
    ext x; constructor; intro hx; by_cases x ‚â• c; left; exact h
    push_neg at h; right; exact h
    intro hx; rcases hx  <;> trivial

  have : IsOpen {x : ‚Ñù | x < c} := by exact isOpen_gt' c
  calc
  ‚à´‚Åª (x : ‚Ñù), f x = ‚à´‚Åª (x : ‚Ñù) in Set.univ, f x ‚àÇ volume := by exact (set_lintegral_univ fun x => f x).symm
  _ = ‚à´‚Åª (x : ‚Ñù) in {x | x ‚â• c} ‚à™ {x | x < c} , f x ‚àÇ volume := by rw [<-union]
  _ = _ := by
    apply lintegral_union;
    . refine real_open_is_measurable this
    . rw [@Set.disjoint_iff]; rintro x ‚ü®hxge, hxlt‚ü©; dsimp only [Set.mem_setOf_eq] at *; linarith --with lemma lt_ge_disjoint?

open ProbabilityTheory

/-- The exponential pdf is measurable. -/

lemma measurable_exponentialPDFReal (rate : ‚Ñù) (ratePos : rate > 0) : Measurable (exponentialPDFReal rate ratePos) := by
  have : Measurable fun x => (rate*(Real.exp (-(‚Üërate*‚Üëx)))):= (measurable_id'.const_mul rate).neg.exp.const_mul rate
  unfold exponentialPDFReal; refine Measurable.ite ?hp this ?hg;
  . refine MeasurableSet.of_compl ?hp.h; apply real_open_is_measurable; rw [comp_of_ge]; exact isOpen_gt' 0 ; exact rate;
  . exact measurable_const

/-

lemma measurable_exponentialPDFRight (rate : ‚Ñù) (ratePos : rate > 0) : Measurable fun x => ENNReal.ofReal ‚Üërate * ENNReal.ofReal (rexp (-(‚Üërate * x))) := by
  have : Measurable fun x => (rate*(Real.exp (-(‚Üërate*‚Üëx)))):= (measurable_id'.const_mul rate).neg.exp.const_mul rate
  unfold exponentialPDFReal; refine Measurable.ite ?hp this ?hg;
  . refine MeasurableSet.of_compl ?hp.h; apply real_open_is_measurable; rw [comp_of_ge]; exact isOpen_gt' 0 ; exact rate;
  . exact measurable_const -/

/-- The exponential pdf is strongly measurable. Needed to transfer lintegral to integral -/

lemma stronglyMeasurable_exponentialPDFReal (rate : ‚Ñù) (ratePos : rate > 0) :
    StronglyMeasurable (exponentialPDFReal rate ratePos) :=
  (measurable_exponentialPDFReal rate ratePos).stronglyMeasurable

lemma exponentialPDFReal_pos (xPos : 0 < x) : exponentialPDFReal rate ratePos x > 0 := by
  unfold exponentialPDFReal
  conv =>
    lhs
    rw[if_pos (le_of_lt xPos)]
  exact mul_pos ratePos (Real.exp_pos _)

lemma exponentialPDFReal_nonneg :‚àÄ x : ‚Ñù, exponentialPDFReal rate ratePos x ‚â• 0 := by
  unfold exponentialPDFReal
  intro x;
  by_cases x ‚â•  0
  . conv =>
      lhs
      rw[if_pos h]
    exact mul_nonneg (le_of_lt ratePos) (le_of_lt (Real.exp_pos _))
  . conv  =>
      lhs
      rw[if_neg h]

lemma IntSeqMonotone : Monotone (fun n : ‚Ñï  => Set.Icc (0 : ‚Ñù) ‚Üën) := by
  refine monotone_nat_of_le_succ ?hf; intro n; refine Set.le_iff_subset.mpr ?hf.a; refine
    Set.Icc_subset_Icc_right ?hf.a.h; refine Nat.cast_le.mpr ?hf.a.h.a; simp only [le_add_iff_nonneg_right]

lemma UnionofIcc : (‚ãÉ n : ‚Ñï , Set.Icc (0 : ‚Ñù) ‚Üën) = Set.Ici 0 := by
  ext x;  simp only [ge_iff_le, Nat.cast_nonneg, not_true, gt_iff_lt, Set.mem_iUnion, Set.mem_Icc, exists_and_left, Set.mem_Ici, and_imp, forall_exists_index];
  constructor; intro h; exact h.1
  intro h; constructor; exact h; exact exists_nat_ge x

lemma IntegrableOnposInterval {b : ‚Ñù} (hb : 0 < b) : IntegrableOn (fun x => rexp (-(b * x))) (‚ãÉ (n : ‚Ñï), Set.Icc (0 : ‚Ñù) ‚Üën) := by
  rw [UnionofIcc]
  --have IntegrableOpen : IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi 0) := by apply (exp_neg_integrableOn_Ioi 0 hb)
  --(hfi : IntegrableOn f (‚ãÉ (n : Œπ), s n))
  have : ‚àÄ x : ‚Ñù , (rexp (-(b * x)) = rexp (-b * x)) := by intro x; rw [@neg_mul_eq_neg_mul]
  simp only [this]
  apply integrableOn_Ici_iff_integrableOn_Ioi.2 (exp_neg_integrableOn_Ioi 0 hb)

/- Approach like R√©my for Gaussian, right now fail to prove Integrability of either all of exponentialPDFReal or its left and right Part

def lintegral_exponentialPDF_eq_one (rate : ‚Ñù) (ratePos : 0 < rate) :
  ‚à´‚Åª (x : ‚Ñù), exponentialPDF rate ratePos x = 1 := by
  rw [‚ÜêENNReal.toReal_eq_one_iff]
  have hfm : AEStronglyMeasurable (exponentialPDFReal rate ratePos) ‚Ñô :=
    (stronglyMeasurable_exponentialPDFReal rate ratePos).aestronglyMeasurable
  have hf : 0 ‚â§‚Çê‚Çõ exponentialPDFReal rate ratePos := ae_of_all _ (exponentialPDFReal_nonneg)

  have integratable : Integrable (fun x => exponentialPDFReal rate ratePos x) := by
    unfold Integrable; constructor; apply hfm;
    unfold HasFiniteIntegral; sorry

  unfold exponentialPDF; rw [‚Üê integral_eq_lintegral_of_nonneg_ae (f:=exponentialPDFReal rate ratePos) hf hfm]
  unfold exponentialPDFReal;
  rw [integral_eq_lt_and_ge (fun x => if x ‚â• 0 then rate * rexp (-(rate * x)) else 0) 0 ?intGE ?intLT]
  . sorry
  . simp only [ge_iff_le]; rw [@integrableOn_def]; unfold Integrable; constructor; apply (StronglyMeasurableAtFilter ?h)
-/


/- Own approach, stays in lintegral for longer, right now end at Part of trying to integrate right side (the real domain of definition) to 1, because of lintegral-/

lemma if_eval_pos : ‚àÄ·µê  x : ‚Ñù ‚àÇ volume , (x ‚àà {x|x < 0} ‚Üí  ENNReal.ofReal (if ((x : ‚Ñù) ‚â•  0) then ( (rate * rexp (-(‚Üërate * x)))) else 0 ) = 0 ):= by
      apply ae_of_all
      intro x hx; split_ifs with h; simp only [ge_iff_le] at h ;
      . contrapose h; push_neg; exact hx
      . exact ENNReal.ofReal_zero

lemma if_eval_neg :  ‚àÄ·µê  x : ‚Ñù ‚àÇ volume , (x ‚àà {x|x ‚â• 0} ‚Üí  ENNReal.ofReal (if ((x : ‚Ñù) ‚â•  0) then (rate * rexp (-(‚Üërate * x))) else 0 ) = ENNReal.ofReal (rate * rexp (-(‚Üërate * x))) ):= by
      apply ae_of_all
      intro x hx; split_ifs with h; simp only [ge_iff_le] at h ;
      . rfl
      contrapose h; simp only [ge_iff_le, not_le, not_lt]; exact hx

lemma rootTendsZero {rate : ‚Ñù} : rate > 0 ‚Üí  Filter.Tendsto (fun x => -1/(rate) * (Real.exp (-(rate * x)))) Filter.atTop (nhds 0) := by
  rw [@Metric.tendsto_atTop]; intro ratePos Œµ Œµpos;
  by_cases Œµ * rate < 1
  use (2*(-(rate)‚Åª¬π*(Real.log (Œµ * rate)))); intro n hn
  simp only [dist_zero_right, norm_mul, norm_div, norm_neg, norm_one, Real.norm_eq_abs, NNReal.abs_eq,
  Real.abs_exp, one_div, ne_eq, NNReal.coe_eq_zero]; apply lt_of_mul_lt_mul_left _ (le_of_lt ratePos); rw[<-mul_assoc, abs_eq_self.2 (le_of_lt ratePos) , mul_inv_cancel, one_mul, <-Real.lt_log_iff_exp_lt (mul_pos ratePos Œµpos), neg_lt];
  have invPos: (0 : ‚Ñù) < (‚Üërate)‚Åª¬π  := by apply inv_pos.2 ratePos
  apply lt_of_mul_lt_mul_left (b:=-Real.log (‚Üërate * Œµ)) _ (le_of_lt invPos);
  simp only [NNReal.val_eq_coe, NNReal.coe_inv, mul_neg, NNReal.coe_eq_zero]
  rw[<-mul_assoc, inv_mul_cancel, one_mul]
  apply lt_of_le_of_lt' hn; rw[mul_comm Œµ, neg_mul]; nth_rw 1 [<-one_mul (-((‚Üërate)‚Åª¬π * Real.log (‚Üërate * Œµ)))]
  apply mul_lt_mul_of_pos_right; norm_num; simp; apply mul_neg_of_pos_of_neg; apply invPos; apply Real.log_neg
  exact mul_pos ratePos Œµpos; rw [mul_comm]; exact h; intro fal; linarith; linarith;
  sorry

  lemma rootTendsZero2 {rate : ‚Ñù} : rate > 0 ‚Üí  Filter.Tendsto (fun x => -1/(rate) * (Real.exp (-(rate * x)))) Filter.atTop (nhds 0) := by
    --intro ratePos; rw[<-mul_zero (-1/rate)]; apply ENNReal.Tendsto.const_mul (a:=(-1/rate)) (b:=0) (f:=Filter.atTop) (m:=(fun x => ENNReal.ofReal (Real.exp (-(rate * x)))))
    sorry

lemma lintegral_exponentialPDF_eq_one1 (rate : ‚Ñù) (ratePos : (0 : ‚Ñù) < rate) :
  ‚à´‚Åª (x : ‚Ñù), exponentialPDF rate ratePos x = 1 := by
    rw [lintegral_eq_lt_and_ge1 (exponentialPDF rate ratePos) 0, ‚ÜêENNReal.toReal_eq_one_iff];

    have leftSide: ‚à´‚Åª (x : ‚Ñù) in {x | x < 0}, exponentialPDF rate ratePos x = 0 := by
      unfold exponentialPDF exponentialPDFReal; rw [set_lintegral_congr_fun (real_open_is_measurable (isOpen_gt' 0)) if_eval_pos]; exact lintegral_zero

    have rightSide: ‚à´‚Åª (x : ‚Ñù) in {x | x ‚â• 0}, exponentialPDF rate ratePos x = ‚à´‚Åª (x : ‚Ñù) in {x | x ‚â• 0}, ENNReal.ofReal (rate * rexp (-(rate * x))) := by
      unfold exponentialPDF exponentialPDFReal; apply set_lintegral_congr_fun _ _
      . refine MeasurableSet.of_compl ?h; rw [comp_of_ge]; refine real_open_is_measurable ?h.h; exact isOpen_gt' 0; exact rate
      exact if_eval_neg

    rw [leftSide]; simp only [ge_iff_le, add_zero];
    rw [rightSide, ENNReal.toReal_eq_one_iff, ‚ÜêENNReal.toReal_eq_one_iff]

    have hf : 0 ‚â§·µê[(restrict‚Çó {x:‚Ñù | x ‚â• 0}) ‚Ñô] (fun x => rate * (rexp (-(rate * x)))) := by
      apply ae_of_all _ ?a;
      have ratePos': (0:‚Ñù) < rate := by assumption
      have expPos : ‚àÄ x : ‚Ñù, 0 < rexp (-(rate * x)) := by intro x; apply Real.exp_pos (-(rate * x))
      simp only [Pi.zero_apply, gt_iff_lt, NNReal.coe_pos]; intro a; apply le_of_lt; rw[<-zero_mul 0]; apply mul_lt_mul'' ratePos' (expPos a); trivial; trivial
    rw [‚Üê @restrict‚Çó_apply, ‚Üê integral_eq_lintegral_of_nonneg_ae hf ?_]
    let F : (‚Ñù ‚Üí ‚Ñù) := fun x => -1/(rate) * (Real.exp (-(rate * x)))
    . simp only [ge_iff_le, restrict‚Çó_apply]; rw [@integral_mul_left, Set.Ici_def];
      rw [@integral_Ici_eq_integral_Ioi]
      have IntegrOn : IntegrableOn (fun x => rexp (-(rate * x))) (Set.Ioi 0) := by simp only [<-neg_mul]; apply exp_neg_integrableOn_Ioi 0 ratePos

      rw [integral_Ioi_of_hasDerivAt_of_tendsto' (f:=F) (root_of_exp ratePos) IntegrOn (rootTendsZero ratePos)]
      simp only [mul_zero, neg_zero, Real.exp_zero, mul_one, _root_.zero_sub]; rw [neg_div]; simp only [one_div,neg_neg, ne_eq, NNReal.coe_eq_zero]; rw[mul_inv_cancel]; linarith
    apply ((measurable_id'.const_mul rate).neg.exp.const_mul rate).stronglyMeasurable.aestronglyMeasurable



/- /-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(a, +‚àû)`.
When a function has a limit at infinity `m`, and its derivative is integrable, then the
integral of the derivative on `(a, +‚àû)` is `m - f a`. Version assuming differentiability
on `[a, +‚àû)`. -/
theorem integral_Ioi_of_hasDerivAt_of_tendsto' (hderiv : ‚àÄ x ‚àà Ici a, HasDerivAt f (f' x) x)
    (f'int : IntegrableOn f' (Ioi a)) (hf : Tendsto f atTop (ùìù m)) :
    ‚à´ x in Ioi a, f' x = m - f a := by
  refine integral_Ioi_of_hasDerivAt_of_tendsto (fun x hx ‚Ü¶ ?_) (fun x hx => hderiv x hx.out.le)
    f'int hf
  exact (hderiv x hx).continuousAt.continuousWithinAt-/


/- Define a Probability Measure on the PDF-/



open MeasureTheory

/- Measure defined by the exponential Distribution -/

noncomputable
def expMeasure (rate : ‚Ñù‚â•0) (ratePos : rate > 0) : Measure ‚Ñù :=
   Measure.withDensity volume (exponentialPDF rate ratePos)

/- Get the CDF of the exponential Distribution by integrating over the PDF-/
