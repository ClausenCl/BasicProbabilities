import Mathlib.Probability.Density
import Mathlib.MeasureTheory.Measure.Lebesgue.Basic
import Mathlib.Probability.Cdf

/- Define the Uniform distribution on an Interval-/

open scoped ENNReal NNReal Real

noncomputable
def uniformPDFReal (a b x : ℝ): ℝ :=
  Set.indicator (Set.uIcc a b)  (fun _ => 1/(abs (b-a))) x

noncomputable
def uniformPDF (a b x : ℝ): ℝ≥0∞ :=
 ENNReal.ofReal (uniformPDFReal a b x)

open MeasureTheory
open Measure

lemma measurable_uniformPDFReal (a b : ℝ) : Measurable (uniformPDFReal a b) := by
  unfold uniformPDFReal; refine Measurable.ite ?hp measurable_const ?hg;
  . simp only [ge_iff_le, Set.setOf_mem_eq]; exact measurableSet_uIcc
  . exact measurable_const

lemma stronglyMeasurable_uniformPDFReal (a b : ℝ) :
    StronglyMeasurable (uniformPDFReal a b) :=
  (measurable_uniformPDFReal a b).stronglyMeasurable

lemma split_uniformLintegral : (∫⁻ (x : ℝ), uniformPDF a b x) = (∫⁻ (x : ℝ) in Set.Iio (a ⊓ b) , uniformPDF a b x) + (∫⁻ (x : ℝ) in Set.uIcc a b, uniformPDF a b x) + (∫⁻ (x : ℝ) in Set.Ioi (a ⊔ b), uniformPDF a b x) := by
  have union : Set.Iio (a ⊓ b) ∪ Set.uIcc a b ∪ Set.Ioi (a ⊔ b) = Set.univ := by
    ext x; unfold Set.uIcc; simp only [ge_iff_le, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt,
      lt_inf_iff, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self, Set.Iio_union_Icc_eq_Iic,
      Set.Iic_union_Ioi, Set.mem_univ]
  rw [<-set_lintegral_univ]; rw[<-lintegral_union, <- lintegral_union]; rw[union]
  exact measurableSet_Ioi
  unfold Set.uIcc; simp only [ge_iff_le, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt,
    lt_inf_iff, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self, Set.Iio_union_Icc_eq_Iic, le_refl,
    Set.Iic_disjoint_Ioi];
  exact measurableSet_uIcc
  unfold Set.uIcc; rw [@Set.disjoint_iff]; intro x; simp only [ge_iff_le, le_sup_iff, inf_le_left, inf_le_right,
    or_self, not_true, gt_iff_lt, lt_inf_iff, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self,
    Set.mem_inter_iff, Set.mem_Iio, Set.mem_Icc, inf_le_iff, Set.mem_empty_iff_false, and_imp]
  intro hxa hxb habx _; rcases habx <;> linarith

@[simp]
lemma Iio_eq_zero : (∫⁻ (x : ℝ) in Set.Iio (a ⊓ b) , uniformPDF a b x) = 0 := by
rw[set_lintegral_congr_fun measurableSet_Iio (g:= fun _ => 0)]; exact lintegral_zero;
apply Filter.eventually_of_forall; unfold uniformPDF uniformPDFReal Set.uIcc Set.indicator; simp only [ge_iff_le,
  Set.mem_Iio, lt_inf_iff, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt, sup_lt_iff,
  lt_self_iff_false, false_and, and_false, and_self, Set.mem_Icc, inf_le_iff, ENNReal.ofReal_eq_zero, and_imp]; intro x hxa hxb;
  rw[if_neg]; push_neg; rintro (falso | falso) <;> linarith

@[simp]
lemma Ioi_eq_zero : (∫⁻ (x : ℝ) in Set.Ioi (a ⊔ b) , uniformPDF a b x) = 0 := by
rw[set_lintegral_congr_fun measurableSet_Ioi (g:= fun _ => 0)]; exact lintegral_zero;
apply Filter.eventually_of_forall; unfold uniformPDF uniformPDFReal Set.uIcc Set.indicator; simp only [ge_iff_le,
  Set.mem_Ioi, sup_lt_iff, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt, lt_inf_iff,
  lt_self_iff_false, false_and, and_false, and_self, Set.mem_Icc, inf_le_iff, one_div, ENNReal.ofReal_eq_zero, and_imp]; intro x hxa hxb;
  rw[if_neg]; push_neg; intro _; exact ⟨hxa, hxb⟩


lemma carrier_of_uniformlintegral : (∫⁻ (x : ℝ), uniformPDF a b x) = (∫⁻ (x : ℝ) in Set.uIcc a b, uniformPDF a b x) := by
  rw[split_uniformLintegral]; simp only [ge_iff_le, Iio_eq_zero, zero_add, Ioi_eq_zero, add_zero]


theorem lintegral_uniformPDF_eq_one (a b : ℝ) (aneqb : a ≠ b):
  ∫⁻ (x : ℝ), uniformPDF a b x = 1 := by
  rw[carrier_of_uniformlintegral];
  unfold uniformPDF uniformPDFReal Set.indicator;
  rw[set_lintegral_congr_fun measurableSet_uIcc (g:= fun _ =>ENNReal.ofReal (1/ |b-a|)) (by apply Filter.eventually_of_forall; intro _ xele; rw[if_pos xele])]
  rw [@set_lintegral_const]; rw[Real.volume_interval];
  simp only [one_div]; rw [<-ENNReal.ofReal_mul' ?nonneg]; rw[inv_mul_cancel ?neq]; simp only [ENNReal.ofReal_one]
  refine ne_iff_lt_or_gt.mpr ?neq.a; right; refine abs_pos.mpr ?neq.a.h.a; exact sub_ne_zero.mpr (id (Ne.symm aneqb))
  exact abs_nonneg (b - a)

/- Measure defined by the exponential Distribution -/

noncomputable
def uniformMeasure (a b : ℝ) : Measure ℝ :=
   volume.withDensity (uniformPDF a b)

instance instIsProbabilityMeasureUniform (a b : ℝ) (aneqb : a ≠ b ) :
    IsProbabilityMeasure (uniformMeasure a b) where
  measure_univ := by unfold uniformMeasure; simp only [MeasurableSet.univ, withDensity_apply, restrict_univ,
    lintegral_uniformPDF_eq_one a b aneqb]

/-- CDF -/
noncomputable
def uniformCDFReal (a b : ℝ) : StieltjesFunction :=
      ProbabilityTheory.cdf (uniformMeasure a b)

