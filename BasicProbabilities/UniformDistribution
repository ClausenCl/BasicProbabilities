import Mathlib.Probability.Density
import Mathlib.MeasureTheory.Measure.Lebesgue.Basic
import Mathlib.Probability.Cdf

/- Define the Uniform distribution on an Interval-/

open scoped ENNReal NNReal Real

noncomputable
def uniformPdfReal (a b x : ℝ): ℝ :=
  Set.indicator (Set.uIcc a b)  (fun _ => 1/(abs (b-a))) x

noncomputable
def uniformPdf (a b x : ℝ): ℝ≥0∞ :=
 ENNReal.ofReal (uniformPdfReal a b x)

open MeasureTheory
open Measure

/- Copied from Basic Distribution-/
lemma lintegral_split_bounded {y z : ℝ}(f: ℝ → ENNReal) (ygez: z ≤ y) :
    ∫⁻ (x : ℝ) in Set.Iic y, f x  =  (∫⁻ (x : ℝ) in Set.Iio z, f x) +  ∫⁻ (x : ℝ) in Set.Icc z y, f x := by
  have union : Set.Iic y = Set.Iio z ∪ Set.Icc z y := by
    ext x; constructor
    . simp only [Set.mem_Iic, ge_iff_le, not_le, gt_iff_lt, Set.mem_union, Set.mem_Iio, Set.mem_Icc]
      intro hxy; by_cases x < z; left; exact h; right; constructor <;> linarith
    simp only [ge_iff_le, not_le, gt_iff_lt, Set.mem_union, Set.mem_Iio, Set.mem_Icc, Set.mem_Iic];
    intro hxy; rcases hxy with h | h;
    . linarith
    . linarith
  rw[union]; apply lintegral_union; exact measurableSet_Icc;
  rw [Set.disjoint_iff]; rintro x ⟨h1, h2⟩;
  simp only [Set.mem_Iio] at h1 ; simp only [gt_iff_lt, not_lt, ge_iff_le, Set.mem_Icc] at h2
  linarith

lemma measurable_uniformPdfReal (a b : ℝ) : Measurable (uniformPdfReal a b) := by
  unfold uniformPdfReal; refine Measurable.ite ?hp measurable_const ?hg;
  . simp only [ge_iff_le, Set.setOf_mem_eq]; exact measurableSet_uIcc
  . exact measurable_const

lemma stronglyMeasurable_uniformPdfReal (a b : ℝ) :
    StronglyMeasurable (uniformPdfReal a b) :=
  (measurable_uniformPdfReal a b).stronglyMeasurable

lemma split_uniformLintegral : (∫⁻ (x : ℝ), uniformPdf a b x)
  = (∫⁻ (x : ℝ) in Set.Iio (a ⊓ b) , uniformPdf a b x)
  + (∫⁻ (x : ℝ) in Set.uIcc a b, uniformPdf a b x)
  + (∫⁻ (x : ℝ) in Set.Ioi (a ⊔ b), uniformPdf a b x) := by
    have union : Set.Iio (a ⊓ b) ∪ Set.uIcc a b ∪ Set.Ioi (a ⊔ b) = Set.univ := by
      ext x; unfold Set.uIcc; simp only [ge_iff_le, le_sup_iff, inf_le_left, inf_le_right, or_self,
        not_true, gt_iff_lt, lt_inf_iff, sup_lt_iff, lt_self_iff_false, false_and, and_false,
        and_self, Set.Iio_union_Icc_eq_Iic, Set.Iic_union_Ioi, Set.mem_univ]
    rw [<-set_lintegral_univ]; rw[<-lintegral_union, <- lintegral_union]; rw[union]
    exact measurableSet_Ioi
    unfold Set.uIcc; simp only [ge_iff_le, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true,
      gt_iff_lt, lt_inf_iff, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self,
       Set.Iio_union_Icc_eq_Iic, le_refl, Set.Iic_disjoint_Ioi];
    exact measurableSet_uIcc
    unfold Set.uIcc; rw [@Set.disjoint_iff]; intro x;
    simp only [ge_iff_le, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt,
      lt_inf_iff, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self, Set.mem_inter_iff,
      Set.mem_Iio, Set.mem_Icc, inf_le_iff, Set.mem_empty_iff_false, and_imp]
    intro hxa hxb habx _; rcases habx <;> linarith

@[simp]
lemma Iio_eq_zero : (∫⁻ (x : ℝ) in Set.Iio (a ⊓ b) , uniformPdf a b x) = 0 := by
rw[set_lintegral_congr_fun measurableSet_Iio (g:= fun _ => 0)]; exact lintegral_zero;
apply Filter.eventually_of_forall;
unfold uniformPdf uniformPdfReal Set.uIcc Set.indicator;
simp only [ge_iff_le, Set.mem_Iio, lt_inf_iff, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true,
  gt_iff_lt, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self, Set.mem_Icc, inf_le_iff,
   one_div, ENNReal.ofReal_eq_zero, and_imp];
  intro x hxa hxb;
  rw[if_neg]; push_neg; rintro (falso | falso) <;> linarith

@[simp]
lemma Ioi_eq_zero : (∫⁻ (x : ℝ) in Set.Ioi (a ⊔ b) , uniformPdf a b x) = 0 := by
rw[set_lintegral_congr_fun measurableSet_Ioi (g:= fun _ => 0)]; exact lintegral_zero;
apply Filter.eventually_of_forall; unfold uniformPdf uniformPdfReal Set.uIcc Set.indicator; simp only [ge_iff_le,
  Set.mem_Ioi, sup_lt_iff, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt, lt_inf_iff,
  lt_self_iff_false, false_and, and_false, and_self, Set.mem_Icc, inf_le_iff, one_div, ENNReal.ofReal_eq_zero, and_imp]; intro x hxa hxb;
  rw[if_neg]; push_neg; intro _; exact ⟨hxa, hxb⟩


lemma carrier_of_uniformlintegral : (∫⁻ (x : ℝ), uniformPdf a b x) = (∫⁻ (x : ℝ) in Set.uIcc a b, uniformPdf a b x) := by
  rw[split_uniformLintegral]; simp only [ge_iff_le, Iio_eq_zero, zero_add, Ioi_eq_zero, add_zero]

theorem lintegral_uniformPdf_eq_one (a b : ℝ) (aneqb : a ≠ b):
  ∫⁻ (x : ℝ), uniformPdf a b x = 1 := by
  rw[carrier_of_uniformlintegral];
  unfold uniformPdf uniformPdfReal Set.indicator;
  rw[set_lintegral_congr_fun measurableSet_uIcc (g:= fun _ =>ENNReal.ofReal (1/ |b-a|)) (by apply Filter.eventually_of_forall; intro _ xele; rw[if_pos xele])]
  rw [@set_lintegral_const]; rw[Real.volume_interval];
  simp only [one_div]; rw [<-ENNReal.ofReal_mul' ?nonneg]; rw[inv_mul_cancel ?neq]; simp only [ENNReal.ofReal_one]
  refine ne_iff_lt_or_gt.mpr ?neq.a; right; refine abs_pos.mpr ?neq.a.h.a; exact sub_ne_zero.mpr (id (Ne.symm aneqb))
  exact abs_nonneg (b - a)

/- Measure defined by the exponential Distribution -/

noncomputable
def uniformMeasure (a b : ℝ) (aneqb : a ≠ b ) : Measure ℝ :=
   volume.withDensity (uniformPdf a b)

instance instIsProbabilityMeasureUniform (a b : ℝ) (aneqb : a ≠ b ) :
    IsProbabilityMeasure (uniformMeasure a b aneqb) where
  measure_univ := by unfold uniformMeasure; simp only [MeasurableSet.univ, withDensity_apply, restrict_univ,
    lintegral_uniformPdf_eq_one a b aneqb]

/-- Cdf -/
noncomputable
def uniformCdfReal (a b : ℝ) (aneqb : a ≠ b ) : StieltjesFunction :=
  ProbabilityTheory.cdf (uniformMeasure a b aneqb)

lemma UniformCdf_eq_Lintegral (a b : ℝ) (aneqb : a ≠ b) : ((uniformCdfReal a b aneqb)) = fun x => ENNReal.toReal (∫⁻ x in (Set.Iic x), (uniformPdf a b x)) := by
  ext x; unfold uniformCdfReal uniformPdf; rw[ProbabilityTheory.cdf_eq_toReal];
  unfold uniformMeasure; simp only [measurableSet_Iic, withDensity_apply]
  rfl

lemma UniformCdf_zero (x : ℝ) : (x < a ⊓ b) → ((uniformCdfReal a b aneqb) x) = 0 := by
  intro h;
  rw[UniformCdf_eq_Lintegral]; unfold uniformPdf uniformPdfReal Set.indicator Set.uIcc;
  dsimp;
  rw[set_lintegral_congr_fun (measurableSet_Iic) (g:= fun _ => ENNReal.ofReal 0)]
  simp only [ENNReal.ofReal_zero, lintegral_const, MeasurableSet.univ, restrict_apply, Set.univ_inter,
    Real.volume_Iic, zero_mul, ENNReal.zero_toReal]
  apply Filter.eventually_of_forall;
  simp only [Set.mem_Iic, ge_iff_le, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt, lt_inf_iff,
    sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self, Set.mem_Icc, inf_le_iff, one_div,
    ENNReal.ofReal_zero, ENNReal.ofReal_eq_zero]
  intro y hy;
  rw[if_neg]; push_neg; intro aorb
  rcases aorb with (fal|fal) <;> simp at h <;> linarith;

lemma UniformCdf_eq_fromInf (x : ℝ) (h : a ⊓ b ≤ x) : ((uniformCdfReal a b aneqb) x) =
     ENNReal.toReal (∫⁻ (x' : ℝ) in Set.Icc (a ⊓ b) x, uniformPdf a b x')  := by
  rw [UniformCdf_eq_Lintegral]; dsimp
  rw [lintegral_split_bounded _ h];
  simp only [ge_iff_le, Iio_eq_zero, inf_le_iff, gt_iff_lt, lt_inf_iff, zero_add]

lemma UniformCdf_eq_toSup (x : ℝ) (h : a ⊔ b ≤ x) : ((uniformCdfReal a b aneqb) x) =
    ENNReal.toReal (∫⁻ (x' : ℝ) in Set.Icc (a ⊓ b) (a ⊔ b), uniformPdf a b x') := by
  rw [UniformCdf_eq_fromInf _ (le_trans inf_le_sup h), (Set.Icc_union_Ioc_eq_Icc inf_le_sup h).symm]
  rw[lintegral_union measurableSet_Ioc ?dis]
  have : ∫⁻ (a_1 : ℝ) in Set.Ioc (a ⊔ b) x, uniformPdf a b a_1 = 0 := by
    unfold uniformPdf uniformPdfReal Set.indicator Set.uIcc;
    simp only [ge_iff_le, sup_le_iff, not_and, not_le, gt_iff_lt, lt_sup_iff, le_sup_iff, inf_le_left, inf_le_right,
      or_self, not_true, lt_inf_iff, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self, Set.mem_Icc,
      inf_le_iff, one_div]
    rw[set_lintegral_congr_fun measurableSet_Ioc (g:=fun _ => 0)]; exact lintegral_zero
    apply Filter.eventually_of_forall; intro x' hx'; rw[if_neg]; exact ENNReal.ofReal_zero
    intro fal; simp at hx'; rcases fal.right <;> linarith
  simp [this];
  rw [Set.disjoint_iff]; rintro x ⟨h1, h2⟩;
  simp only [Set.mem_Icc] at h1 ; simp only [gt_iff_lt, not_lt, ge_iff_le, Set.mem_Ioc] at h2
  linarith

lemma UniformCdf_eq {a b : ℝ} (aneqb: a ≠ b) : (uniformCdfReal a b aneqb) =
    fun x => ite ((a ⊓ b) ≤ x) (min ((x- (a ⊓ b))/((a ⊔ b) - (a ⊓ b))) 1) 0 := by
  ext top; by_cases (top < (a ⊓ b))
  . rw[if_neg]
    exact UniformCdf_zero top h
    linarith
  by_cases h' : top ≤ (a ⊔ b)
  . push_neg at h
    rw[UniformCdf_eq_fromInf _ h];
    unfold uniformPdf uniformPdfReal Set.indicator Set.uIcc;
    . simp only [ge_iff_le, inf_le_iff, gt_iff_lt, lt_inf_iff, le_sup_iff, inf_le_left, inf_le_right, or_self,
        not_true, sup_lt_iff, lt_self_iff_false, false_and, and_false, and_self, Set.mem_Icc]
      rw [set_lintegral_congr_fun measurableSet_Icc (g:=(fun _ =>ENNReal.ofReal (1 / ((a ⊔ b) - (a ⊓ b)))))]
      rw[if_pos (by simp at h; exact h)]
      rw [min_eq_left]
      simp only [ge_iff_le, inf_le_iff, gt_iff_lt, lt_inf_iff, lintegral_const, MeasurableSet.univ,
        restrict_apply, Set.univ_inter, Real.volume_Icc, ENNReal.toReal_mul, inv_nonneg, sub_nonneg, le_sup_iff,
        inf_le_left, inf_le_right, or_self, ENNReal.toReal_ofReal]
      simp only [ge_iff_le, one_div, inv_nonneg, sub_nonneg, le_sup_iff, inf_le_left, inf_le_right, or_self,
        ENNReal.toReal_ofReal, inf_le_iff]
      rw [@inv_mul_eq_div, ENNReal.toReal_ofReal]; linarith
      rw [div_le_one]; linarith;
      simp only [ge_iff_le, sub_pos, lt_sup_iff, inf_lt_left, not_le, inf_lt_right, lt_or_lt_iff_ne];
      exact id (Ne.symm aneqb)
      apply Filter.eventually_of_forall; rintro x ⟨hab, htop⟩
      rw [if_pos]; rw [@LatticeOrderedGroup.sup_sub_inf_eq_abs_sub]
      simp at hab; simp at h'; constructor; exact hab; rcases h'; left; linarith; right; linarith
  . push_neg at h'
    rw [UniformCdf_eq_toSup _ h'.le]
    unfold uniformPdf uniformPdfReal Set.indicator Set.uIcc;
    rw [set_lintegral_congr_fun measurableSet_Icc (g:=(fun _ =>ENNReal.ofReal (1 / ((a ⊔ b) - (a ⊓ b)))))]
    . rw[if_pos (by push_neg at h; exact h)]
      simp only [ge_iff_le, le_sup_iff, inf_le_left, inf_le_right, or_self, not_true, gt_iff_lt, lt_inf_iff, sup_lt_iff,
        lt_self_iff_false, false_and, and_false, and_self, one_div, lintegral_const, MeasurableSet.univ, restrict_apply,
        Set.univ_inter, Real.volume_Icc, ENNReal.toReal_mul, inv_nonneg, sub_nonneg, ENNReal.toReal_ofReal, ne_eq]
      rw[inv_mul_cancel, min_eq_right];
      rw[one_le_div];
      . simp only [ge_iff_le, tsub_le_iff_right, sub_add_cancel]; exact le_of_lt h';
      rw [@sub_pos]; exact inf_lt_sup.mpr aneqb
      rw [@sub_ne_zero]; apply (ne_of_lt (inf_lt_sup.mpr aneqb)).symm
    apply Filter.eventually_of_forall; intro x hx; rw[if_pos hx, @LatticeOrderedGroup.sup_sub_inf_eq_abs_sub]
